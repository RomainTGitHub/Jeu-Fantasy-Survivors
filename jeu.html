<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fantasy Survivors</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Press Start 2P',-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 4px solid #5a3d2b;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000;
            width: clamp(320px, 90vw, 1400px);
            height: clamp(240px, 85vh, 900px);
            overflow: hidden; /* Ensure content doesn't spill out */
            transition: border-color 0.1s ease-out, box-shadow 0.1s ease-out; /* Smooth transition for damage feedback */
        }
        /* New CSS for damage feedback */
        #game-container.damage-overlay {
            border-color: #ff0000; /* Red border on damage */
            box-shadow: 0 0 25px 10px rgba(255,0,0,0.7); /* Red glow effect */
        }
        canvas {
            display: block;
            background-color: #333; /* Fallback */
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            pointer-events: none;
        }
        #stats {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            color: #fff;
            text-shadow: 2px 2px 2px #000;
        }
        #health-bar-container, #xp-bar-container {
            width: 100%;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #fff;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
            position: relative; /* Added for absolute positioning of bar-text */
        }
        #health-bar {
            height: 100%;
            /* Supprimé: transition: width 0.2s ease-in-out; */
        }
        #xp-bar {
            height: 100%;
            transition: width 0.2s ease-in-out;
        }
        #health-bar { background-color: #c0392b; }
        #xp-bar { background-color: #2980b9; }

        /* Styles for text on bars */
        .bar-text {
            position: absolute;
            top: 0; /* Explicitly position at the top */
            left: 0; /* Explicitly position at the left */
            width: 100%;
            height: 100%; /* Make it take full height of parent */
            display: flex; /* Use flexbox for centering */
            align-items: center; /* Vertically center */
            justify-content: center; /* Horizontally center */
            font-size: 14px;
            color: #fff;
            text-shadow: 1px 1px 1px #000;
            pointer-events: none; /* Ensure it doesn't block clicks */
            z-index: 1; /* Ensure it's above the bar but below other UI */
        }
        /* Style for gold display */
        #gold-display {
            position: absolute;
            top: 100px;
            bottom: 5px;
            right: 5px;
            font-size: 16px;
            color: #f1c40f;
            text-shadow: 2px 2px #000;
            pointer-events: none;
            z-index: 5;
        }

        .modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        .modal h2 { font-size: 24px; color: #f1c40f; margin-bottom: 20px; }
        .modal-content {
            background-color: #2c2c2c;
            padding: 30px;
            border: 4px solid #5a3d2b;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
        }
        .upgrade-option {
            background-color: #4a4a4a;
            border: 2px solid #eee;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 5px;
        }
        .upgrade-option:hover { background-color: #f1c40f; color: #1a1a1a; }
        #game-over-modal button, #main-menu button, #pause-modal button, #victory-modal button { /* Ajout des boutons de modal */
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 30px;
            background-color: #f1c40f;
            color: #1a1a1a;
            border: none;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 5px;
        }

        /* Styles du menu principal */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20; /* Assurez-vous qu'il est au-dessus de tout le reste */
        }
        #main-menu h1 {
            font-size: 48px;
            color: #f1c40f;
            margin-bottom: 40px;
            text-shadow: 4px 4px 0px #e67e22;
        }
        /* Adjusted margin-top for buttons in main menu */
        #main-menu button {
            margin-top: 15px; /* Smaller margin between buttons */
            margin-bottom: 5px; /* Add some space below each button */
        }
        #main-menu-gold { /* Style for gold display on main menu */
            font-size: 20px;
            color: #f1c40f;
            text-shadow: 2px 2px 2px #000;
            margin-top: 20px;
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container"></div>
    <!-- Main Menu -->
    <div id="main-menu">
        <h1>Fantasy Survivors</h1>
        <button id="startGameButton">Jouer !</button>
        <button id="upgradesMenuButton">Améliorations</button>
        <p id="main-menu-gold">Or: 0</p> <!-- Gold display on main menu -->
    </div>
    <!-- Pause Menu -->
    <div id="pause-modal" class="modal">
        <div class="modal-content">
            <h2>PAUSE</h2>
            <div id="pause-stats">
                <p id="pause-level">Niveau: </p>
                <p id="pause-timer">Temps écoulé: </p>
                <p id="pause-kill-count">Kills: </p>
            </div>
            <div id="pause-upgrades">
                <h3>Améliorations:</h3>
                <ul id="pause-upgrades-list"></ul>
            </div>
            <button onclick="resumeGame()">Reprendre</button>
            <!-- Nouveau bouton pour quitter la partie -->
            <button onclick="quitGame()">Quitter la partie</button> 
        </div>
    </div>
    <!-- Victory Screen -->
    <div id="victory-modal" class="modal">
        <div class="modal-content">
            <h2>VICTOIRE !</h2>
            <p>Vous avez survécu 30 minutes !</p>
            <button onclick="window.location.reload()">Recommencer</button>
        </div>
    </div>
</div>
<script>
    // No Firebase imports needed for localStorage persistence
    // Global variables for game state and UI elements
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const uiContainer = document.getElementById('ui-container');
    const mainMenu = document.getElementById('main-menu'); // Reference to the main menu
    const pauseModal = document.getElementById('pause-modal'); // Reference to the pause menu
    const victoryModal = document.getElementById('victory-modal'); // Reference to the victory modal
    let mainMenuGoldUI; // Reference to the gold display on main menu

    // --- Asset Loading ---
    const assets = {};
    // Game image sources
    const assetSources = {
        player: 'images/player_spritesheet.png',
        goblin: 'images/goblin_spritesheet.png',
        skeleton: 'images/skeleton_spritesheet.png',
        slime: 'images/slime_spritesheet.png',
        orc: 'images/orc_spritesheet.png',
        xpGem: 'images/xpGem_spritesheet.png',
        background: 'images/background.png',
        obstacle: 'images/obstacles.png',
        gold: 'images/gold_spritesheet.png', // New gold spritesheet
        // magicMissileSprite: 'images/magicprojectile_spritesheet.png' // Removed: not using sprite for magic missile
    };

    // Loads all images defined in assetSources
    function loadAssets(callback) {
        let loadedCount = 0;
        const totalAssets = Object.keys(assetSources).length;
        for (const key in assetSources) {
            assets[key] = new Image();
            assets[key].src = assetSources[key];
            assets[key].onload = () => {
                loadedCount++;
                if (loadedCount === totalAssets) {
                    callback();
                }
            };
            // Handles image loading errors by using a magenta square
            assets[key].onerror = () => {
              console.error(`Failed to load asset: ${key} at ${assetSources[key]}`);
              const canvas = document.createElement('canvas');
              const w = 64, h = 64;
              canvas.width = w;
              canvas.height = h;
              const assetCtx = canvas.getContext('2d');
              assetCtx.fillStyle = 'magenta';
              assetCtx.fillRect(0, 0, w, h);
              assets[key].src = canvas.toDataURL();
              loadedCount++;
              if (loadedCount === totalAssets) {
                    callback();
                }
            };
        }
    }

    // --- Game State & World Setup ---
    // Game world dimensions
    const world = { width: 3000, height: 3000 };
    let obstacles = [], backgroundPattern;
    // User interface elements
    let levelUI, timerUI, killCountUI, healthBarUI, xpBarUI, healthTextUI, xpTextUI, goldUI, // Added goldUI
        levelUpModal, upgradeOptionsContainer, gameOverModal, finalScoreUI,
        pauseLevelUI, pauseTimerUI, pauseKillCountUI, pauseUpgradesList; // New UI elements for pause
    // Game state
    let gameState = { running: false, paused: true, gameTime: 0, killCount: 0, gameStarted: false }; // Added gameStarted
    // Keyboard key state
    let keys = {};
    // Debug modes
    let debugMode = false;
    let debugGalleryMode = false;
    // Game camera
    let camera = { x: 0, y: 0 };
    // Game entities
    let projectiles = [], enemies = [], xpGems = [], goldCoins = []; // New goldCoins array
    let enemySpawnTimer = 0;

    // Player properties (added visualOffsetX and visualOffsetY)
    const player = {
        x:world.width/2,y:world.height/2, w: 75, h: 135, spriteW: 128, spriteH: 160, hitboxOffsetX: 0, hitboxOffsetY: 0,
        visualOffsetX: 0, visualOffsetY: -10, // New offsets for visual rendering
        speed:4,health:120,maxHealth:120,xp:0,level:1,xpToNextLevel:8,magnetRadius:100, gold: 0, // Added gold property
        regenerationRate: 0, // New: health points per second to regenerate
        invincible: false, // New: player invincibility state
        invincibilityEndTime: 0, // New: invincibility end time
        anim:{frame:0, timer:0, speed: 15, isMoving:false,facingRight:true},
        weapons:{magicMissile:{level:1,cooldown:1200,lastShot:0,damage:12},
        aura:{level:0,radius:80,damage:5,cooldown:100,lastTick:0,rotation:0,orbCount:0},
        auraOfDecay:{level:0,radius:120,damage:2,cooldown:500,lastTick:0}},
    };
    // Enemy definitions (added visualOffsetX and visualOffsetY)
    const enemyDefinitions={
        goblin:{type:'goblin',w:35,h:60,spriteW:128,spriteH:160, hitboxOffsetX: 45, hitboxOffsetY: 70, visualOffsetX: 0, visualOffsetY: 0, speed:1.5,health:8,damage:4,xp:2, frameCount: 10, animSpeed: 10},
        skeleton:{type:'skeleton',w:40,h:70,spriteW:64,spriteH:80, hitboxOffsetX: 12, hitboxOffsetY: 5, visualOffsetX: 0, visualOffsetY: 0, speed:1,health:20,damage:10,xp:5, frameCount: 8, animSpeed: 20},
        slime:{type:'slime',w:40,h:30,spriteW:100,spriteH:80, hitboxOffsetX: 30, hitboxOffsetY: 30, visualOffsetX: 0, visualOffsetY: 0, speed:0.8,health:30,damage:8,xp:7, frameCount: 16, animSpeed: 25},
        orc:{type:'orc',w:50,h:110,spriteW:128,spriteH:160, hitboxOffsetX: 35, hitboxOffsetY: 22, visualOffsetX: 0, visualOffsetY: 0, speed:1.2,health:50,damage:15,xp:15, frameCount: 13, animSpeed: 18},
    };
    // Object definitions (e.g., XP gems, gold)
    const itemDefinitions = {
        xpGem: { frameCount: 7, animSpeed: 10, visualOffsetX: 0, visualOffsetY: 0 },
        gold: { frameCount: 6, animSpeed: 10, visualOffsetX: 0, visualOffsetY: 0 } // Gold coin definition
    };
    // Projectile definitions (new for animated projectiles)
    const projectileDefinitions = {
        magicMissile: {
            drawW: 32, // Desired drawing width on canvas
            drawH: 32, // Desired drawing height on canvas
            maxTrailLength: 10, // Max number of trail points
            trailOpacityStart: 0.8, // Opacity for the newest trail point
            trailOpacityEnd: 0.1, // Opacity for the oldest trail point
        }
    };

    player.frameCount = 4; // Number of frames for player animation
    // Available upgrades when leveling up
    const availableUpgrades=[
        {
            id:'magicMissile',
            name:'Missile Magique',
            description:(l)=>l===0?'Lance un projectile magique.':`+ rapide, + dégâts.`,
            apply:()=>{
                const w=player.weapons.magicMissile;
                w.level++;
                // Decrease cooldown by 5% (increase fire rate)
                w.cooldown=Math.max(500, w.cooldown * 0.95); // Reduce cooldown by 5%
                w.damage+=5;
            }
        },
        {id:'aura',name:'Orbes de Feu',description:(l)=>l===0?'Un orbe de feu vous protège.':`+1 orbe, + dégâts.`,apply:()=>{const w=player.weapons.aura;w.level++;w.orbCount=w.level;w.damage+=3;if(w.level>1)w.radius+=10;}},
        {id:'auraOfDecay',name:'Aura Néfaste',description:(l)=>l===0?'Une aura qui blesse les ennemis proches.':`+ grande zone, + de dégâts.`,apply:()=>{const w=player.weapons.auraOfDecay;w.level++;w.damage+=2;w.radius+=20;}},
        {id:'maxHealth',name:'Coeur robuste',description:()=>`+20 Vie max, soigne complètement.`,apply:()=>{player.maxHealth+=20;player.health=player.maxHealth;}},
        {id:'speed',name:'Bottes de vitesse',description:()=>`Augmente la vitesse.`,apply:()=>{player.speed+=0.5;}},
        {
            id:'regeneration',
            name:'Régénération',
            description:()=>`Régénère passivement la vie. (+0.5 PV/sec)`, // Description for the upgrade
            apply:()=>{player.regenerationRate+=0.5;}
        }
    ];

    // Creates the background and obstacles of the world
    function createBackgroundAndObstacles(){obstacles=[];obstacles.push({x:-10,y:0,w:10,h:world.height},{x:world.width,y:0,w:10,h:world.height},{x:0,y:-10,w:world.width,h:10},{x:0,y:world.height,w:world.width,h:10});const pW=120,pH=160;const pP=[{x:500,y:500},{x:2500,y:500},{x:500,y:2500},{x:2500,y:2500},{x:1500,y:1000},{x:1500,y:2000}];pP.forEach(p=>{obstacles.push({x:p.x,y:p.y,w:pW,h:pH});});}
    
    // Adjusts canvas size based on game container
    function resizeCanvas() {
        canvas.width = gameContainer.clientWidth;
        canvas.height = gameContainer.clientHeight;
        // Optionally, recalculate camera position or other elements that depend on canvas size
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;
        // Redraw immediately after resize to prevent flicker or empty canvas
        draw(); 
    }
    
    // Handles key press and release events
    document.addEventListener('keydown', (e) => { 
        // Removed: if (!gameState.gameStarted) { startGame(); return; } // Game starts only by button click
        keys[e.key.toLowerCase()] = true; 

        if (e.key.toLowerCase() === 'escape') { // Handles Escape key for pause
            console.log('Escape key pressed.');
            console.log('Current gameState.paused:', gameState.paused);
            if (gameState.running && !debugGalleryMode) { // Do not pause if game is already over or in debug gallery mode
                if (gameState.paused) {
                    pauseGame();
                } else {
                    pauseGame();
                }
            } else {
                console.log('Pause blocked: gameState.running:', gameState.running, 'debugGalleryMode:', debugGalleryMode);
            }
        }
        
        if (e.key.toLowerCase() === 'h') {
            debugMode = !debugMode; // Toggles debug mode
            // No longer force debugGalleryMode to false
        }
        if (e.key.toLowerCase() === 'g') {
            debugGalleryMode = !debugGalleryMode; // Toggles debug gallery mode
            uiContainer.style.display = debugGalleryMode ? 'none' : 'block';
            // No longer force debugMode to false
        }
    });
    document.addEventListener('keyup',(e)=>{keys[e.key.toLowerCase()]=false;});

    // Calculates entity hitbox
    function getHitbox(entity) {
        return {
            x: entity.x + (entity.hitboxOffsetX || 0),
            y: entity.y + (entity.hitboxOffsetY || 0),
            w: entity.w,
            h: entity.h
        };
    }

    // Checks collision between two rectangles
    function checkCollision(r1,r2){return r1.x<r2.x+r2.w&&r1.x+r1.w>r2.x&&r1.y<r2.y+r2.h&&r1.y+r1.h>r2.y;}
    // Checks collision of a rectangle with a list of objects
    function checkCollisionWithObjects(rect,list){for(const o of list)if(checkCollision(rect,o))return true;return false;}
    
    // Updates player position and animation
    function updatePlayer(){if(!gameState.running||gameState.paused)return;let dx=0,dy=0;if(keys['w']||keys['z'])dy-=1;if(keys['s'])dy+=1;if(keys['a']||keys['q'])dx-=1;if(keys['d'])dx+=1;player.anim.isMoving=(dx!==0||dy!==0);if(player.anim.isMoving){if(dx!==0)player.anim.facingRight=dx>0;const m=Math.sqrt(dx*dx+dy*dy);const mx=(dx/m)*player.speed;const my=(dy/m)*player.speed;const nextPos = getHitbox(player);nextPos.x += mx;if(!checkCollisionWithObjects(nextPos,obstacles))player.x+=mx;nextPos.x-=mx;nextPos.y+=my;if(!checkCollisionWithObjects(nextPos,obstacles))player.y+=my;}player.anim.timer++;if(player.anim.timer>player.anim.speed){player.anim.timer=0;if(player.anim.isMoving)player.anim.frame=(player.anim.frame+1)%player.frameCount;else player.anim.frame=0;}}
    // Spawns enemies
    function spawnEnemies(){
        if(gameState.paused)return;
        
        // Adjusts time between each enemy wave (longer at first)
        const initialSpawnDelay = 2000; // ms
        const minSpawnDelay = 300; // ms
        const spawnDelayReductionRate = 0.01; // ms reduction per ms of gameTime (slows down game hardening)
        const currentSpawnDelay = Math.max(minSpawnDelay, initialSpawnDelay - gameState.gameTime * spawnDelayReductionRate);
        
        enemySpawnTimer -= 16; // Decreases timer by 16ms (approx. one frame time)
        if(enemySpawnTimer <= 0){
            enemySpawnTimer = currentSpawnDelay; // Resets timer with new difficulty value
            
            // Adjusts number of enemies per wave (lower at first)
            const initialEnemiesPerSpawn = 1;
            const enemyIncreaseRate = 1 / 90000; // 1 additional enemy every 90 seconds
            const maxEnemiesPerSpawn = 10; // Limits maximum number of enemies per wave
            const currentEnemiesToSpawn = Math.min(maxEnemiesPerSpawn, initialEnemiesPerSpawn + Math.floor(gameState.gameTime * enemyIncreaseRate));

            for(let i=0;i<currentEnemiesToSpawn;i++){
                let x,y,sR,ok=false;
                for(let a=0;a<10;a++){ // Tries 10 times to find a valid position
                    const an=Math.random()*Math.PI*2;
                    const d=Math.max(canvas.width/2,canvas.height/2)+50; // Distance from player
                    x=player.x+Math.cos(an)*d;
                    y=player.y+Math.sin(an)*d;
                    
                    // Uses new logic to get enemy type
                    const tK=getEnemyTypeByTime();
                    const t=enemyDefinitions[tK];
                    
                    sR={x,y,w:t.w,h:t.h,hitboxOffsetX:t.hitboxOffsetX,hitboxOffsetY:t.hitboxOffsetY};
                    if(!checkCollisionWithObjects(getHitbox(sR),obstacles)&&x>0&&x<world.width&&y>0&&y<world.height){
                        ok=true;
                        break;
                    }
                }
                if(ok){
                    const tK=getEnemyTypeByTime();
                    const t=enemyDefinitions[tK];
                    // Initializes lastDamageTime for each new enemy
                    enemies.push({x,y,...t,currentHealth:t.health,anim:{frame:0,timer:0,speed:t.animSpeed}, lastDamageTime: 0});
                }
            }
        }
    }
    // Determines enemy type to spawn based on game time
    function getEnemyTypeByTime(){
        const gameTimeSeconds = gameState.gameTime / 1000;
        let availableEnemyTypes = ['goblin']; // Goblins always appear

        if (gameTimeSeconds >= 5 * 60) { // After 5 minutes (300 seconds)
            availableEnemyTypes.push('skeleton');
        }
        if (gameTimeSeconds >= 10 * 60) { // After 10 minutes (600 seconds)
            availableEnemyTypes.push('slime');
        }
        if (gameTimeSeconds >= 15 * 60) { // After 15 minutes (900 seconds)
            availableEnemyTypes.push('orc');
        }

        // Selects a random enemy type from available ones
        const randomIndex = Math.floor(Math.random() * availableEnemyTypes.length);
        return availableEnemyTypes[randomIndex];
    }
    // Updates enemy position and animation
    function updateEnemies(){
        const now = Date.now();
        enemies.forEach(e=>{
            const dx=player.x-e.x;
            const dy=player.y-e.y;
            const d=Math.sqrt(dx*dx+dy*dy);
            if(d>1){
                const mx=(dx/d)*e.speed;
                const my=(dy/d)*e.speed;
                const nextPos=getHitbox(e);
                nextPos.x+=mx;
                if(!checkCollisionWithObjects(nextPos,obstacles))e.x+=mx;
                nextPos.x-=mx;
                nextPos.y+=my;
                if(!checkCollisionWithObjects(nextPos,obstacles))e.y+=my;
            }
            // Checks collision and enemy damage cooldown
            if(checkCollision(getHitbox(player),getHitbox(e))){
                const damageCooldown = 1000; // 1 second delay between each damage inflicted by an enemy
                if (now - e.lastDamageTime > damageCooldown) {
                    takeDamage(e.damage); // Calls takeDamage without the 'enemy' argument
                    e.lastDamageTime = now; // Updates last damage inflicted time for this enemy
                }
            }
            e.anim.timer++;
            if(e.anim.timer>e.anim.speed){
                e.anim.timer=0;
                e.anim.frame=(e.anim.frame+1)%e.frameCount;
            }
        });
    }
    // Handles enemy death
    function killEnemy(enemy){
        enemy.isDead=true;
        gameState.killCount++;
        if(Math.random()<0.8){ // 80% chance to spawn an XP gem
            const gemInfo = itemDefinitions.xpGem;
            xpGems.push({
                x:enemy.x+enemy.w/2,
                y:enemy.y+enemy.h/2,
                value:enemy.xp,
                anim: { frame: 0, timer: 0, speed: gemInfo.animSpeed },
                frameCount: gemInfo.frameCount,
                visualOffsetX: gemInfo.visualOffsetX, // Copies visual offset
                visualOffsetY: gemInfo.visualOffsetY,  // Copies visual offset
                expirationTime: Date.now() + 30000 // Gem disappears after 30 seconds (30000 ms)
            });
        }

        // New gold drop logic
        let dropChance = 0;
        switch (enemy.type) {
            case 'goblin':
                dropChance = 0.10; // 10%
                break;
            case 'skeleton':
                dropChance = 0.12; // 12%
                break;
            case 'slime':
                dropChance = 0.14; // 14%
                break;
            case 'orc':
                dropChance = 0.15; // 15%
                break;
        }

        if (Math.random() < dropChance) {
            const goldInfo = itemDefinitions.gold;
            goldCoins.push({
                x: enemy.x + enemy.w / 2,
                y: enemy.y + enemy.h / 2,
                value: 1, // Value of gold coin
                anim: { frame: 0, timer: 0, speed: goldInfo.animSpeed },
                frameCount: goldInfo.frameCount,
                visualOffsetX: goldInfo.visualOffsetX,
                visualOffsetY: goldInfo.visualOffsetY,
                expirationTime: Date.now() + 60000 // Gold disappears after 60 seconds (60000 ms)
            });
        }

        enemies=enemies.filter(en=>en!==enemy);
    }
    // Updates XP gems (animation, magnetism, collection, expiration)
    function updateXPGems() {
        const now = Date.now();
        for (let i=xpGems.length-1;i>=0;i--){
            const g=xpGems[i];

            // Checks gem expiration
            if (now >= g.expirationTime) {
                xpGems.splice(i, 1);
                continue; // Moves to next gem
            }

            g.anim.timer++;
            if(g.anim.timer>g.anim.speed){
                g.anim.timer=0;
                g.anim.frame=(g.anim.frame+1)%g.frameCount;
            }
            const dx=(player.x+player.w/2)-g.x;
            const dy=(player.y+player.h/2)-g.y;
            const d=Math.sqrt(dx*dx+dy*dy);
            if(d<player.magnetRadius){
                g.x+=(dx/d)*6;
                g.y+=(dy/d)*6;
            }
            if(d<player.w/2){
                collectXP(g.value);
                xpGems.splice(i,1);
            }
        }
    }

    // Updates Gold coins (animation, magnetism, collection, expiration)
    function updateGoldCoins() {
        const now = Date.now();
        for (let i = goldCoins.length - 1; i >= 0; i--) {
            const coin = goldCoins[i];

            // Check coin expiration
            if (now >= coin.expirationTime) {
                goldCoins.splice(i, 1);
                continue; // Move to next coin
            }

            coin.anim.timer++;
            if (coin.anim.timer > coin.anim.speed) {
                coin.anim.timer = 0;
                coin.anim.frame = (coin.anim.frame + 1) % coin.frameCount;
            }

            const dx = (player.x + player.w / 2) - coin.x;
            const dy = (player.y + player.h / 2) - coin.y;
            const d = Math.sqrt(dx * dx + dy * dy);

            if (d < player.magnetRadius) {
                coin.x += (dx / d) * 6;
                coin.y += (dy / d) * 6;
            }

            if (d < player.w / 2) { // Player collects coin
                player.gold += coin.value;
                goldCoins.splice(i, 1);
            }
        }
    }

    // Collects XP and checks if player levels up
    function collectXP(amount){player.xp+=amount;if(player.xp>=player.xpToNextLevel){levelUp();}}
    // Handles player leveling up
    function levelUp(){gameState.paused=true;player.level++;player.xp-=player.xpToNextLevel;player.xpToNextLevel=Math.floor(player.xpToNextLevel*1.5);player.health=player.maxHealth;levelUpModal.style.display='flex';populateUpgradeOptions();}
    // Populates upgrade options
    function populateUpgradeOptions(){upgradeOptionsContainer.innerHTML='';const c=[],a=[...availableUpgrades];while(c.length<3&&a.length>0){const r=Math.floor(Math.random()*a.length);const o=a[r];const wL=(o.id==='magicMissile'||o.id==='aura'||o.id==='auraOfDecay')?player.weapons[o.id]?.level||0:-1;const d=document.createElement('div');d.className='upgrade-option';d.innerHTML=`<strong>${o.name}</strong><br><small>${o.description(wL)}</small>`;d.onclick=()=>selectUpgrade(o);upgradeOptionsContainer.appendChild(d);c.push(o);a.splice(r,1);}}
    // Selects an upgrade
    function selectUpgrade(upgrade){upgrade.apply();levelUpModal.style.display='none';gameState.paused=false;}
    
    // Handles damage taken by the player
    function takeDamage(amount){ 
        const now = Date.now();
        // If player is currently invincible, do not take damage
        if (player.invincible && now < player.invincibilityEndTime) {
            return;
        }

        player.health-=amount;
        
        // Activates invincibility after taking damage
        player.invincible = true;
        player.invincibilityEndTime = now + 1000; // Invincible for 1 second (1000 ms)

        // Add damage overlay class to game container
        gameContainer.classList.add('damage-overlay');
        // Remove the class after a short delay to create a flash effect
        setTimeout(() => {
            gameContainer.classList.remove('damage-overlay');
        }, 200); // Flash for 200 milliseconds


        if(player.health<=0){
            player.health=0;
            gameOver();
        }
    }

    // Function to update player invincibility state
    function updatePlayerInvincibility() {
        const now = Date.now();
        if (player.invincible && now >= player.invincibilityEndTime) {
            player.invincible = false; // Deactivates invincibility if time is up
        }
    }

    // Handles game over
    async function gameOver(){
        gameState.running=false;
        finalScoreUI.textContent=`Survécu ${Math.floor(gameState.gameTime/1000)}s, ${gameState.killCount} kills.`;
        gameOverModal.style.display='flex';
        savePlayerGold(); // Save gold on game over
    }
    
    // Victory function
    async function gameVictory() {
        gameState.running = false;
        victoryModal.style.display = 'flex';
        // You can add victory-specific information here, like final time
        savePlayerGold(); // Save gold on victory
    }

    // Function to check if an enemy is visible on screen
    function isEnemyVisible(enemy) {
        const enemyScreenX = enemy.x - camera.x;
        const enemyScreenY = enemy.y - camera.y;

        // Checks if enemy's bounding box (using sprite dimensions for visibility)
        // overlaps with canvas bounding box (0,0,canvas.width,canvas.height)
        return enemyScreenX < canvas.width && 
               enemyScreenX + enemy.spriteW > 0 &&
               enemyScreenY < canvas.height && 
               enemyScreenY + enemy.spriteH > 0;
    }

    // Finds the nearest enemy to the player that is visible and within missile range
    function findNearestEnemy(){
        let nearest = null;
        let minDistance = Infinity;
        // Define missile range as half of canvas width
        const missileRange = 500;

        enemies.forEach(e=>{
            // Calculate enemy distance from player
            const distanceToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
            
            // Only consider visible enemies AND within range for magic missile targeting
            if (isEnemyVisible(e) && distanceToPlayer <= missileRange) {
                if(distanceToPlayer < minDistance){
                    minDistance = distanceToPlayer;
                    nearest = e;
                }
            }
        });
        return nearest;
    }
    // Formats time in MM:SS:ms format
    function formatTime(milliseconds) {
        const totalSeconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        const ms = Math.floor((milliseconds % 1000) / 10); // Get milliseconds to two digits

        const pad = (num) => String(num).padStart(2, '0');
        const padMs = (num) => String(num).padStart(2, '0'); // For milliseconds

        return `${pad(minutes)}:${pad(seconds)}:${padMs(ms)}`;
    }

    // Updates user interface (UI)
    function updateUI(){
        levelUI.textContent=`Niveau: ${player.level}`;
        timerUI.textContent=`Temps: ${formatTime(gameState.gameTime)}`; // Updated to use formatTime
        killCountUI.textContent=`Kills: ${gameState.killCount}`;
        healthBarUI.style.width=`${(player.health/player.maxHealth)*100}%`;
        xpBarUI.style.width=`${(player.xp/player.xpToNextLevel)*100}%`;
        
        // Update text content for health and XP bars
        healthTextUI.textContent = `${Math.floor(player.health)}/${player.maxHealth}`;
        xpTextUI.textContent = `${Math.floor(player.xp)}/${player.xpToNextLevel}`;
        goldUI.textContent = player.gold; // Update gold count
    }
    // Updates player weapons
    function updateWeapons(){
        const now=Date.now();
        const mm=player.weapons.magicMissile;
        if(mm.level>0 && now-mm.lastShot > mm.cooldown){
            const target=findNearestEnemy(); // findNearestEnemy already checks visibility and range
            if(target){ 
                mm.lastShot=now;
                const dx=target.x-player.x;
                const dy=target.y-player.y;
                const angle=Math.atan2(dy,dx);
                // Lifespan adjusted to match half of canvas width at projectile speed
                // Projectile speed is 8px per frame (assuming 60fps, but calculating based on distance).
                // Distance = range (canvas.width / 2) / projectile_speed_per_frame
                // If speed is 8, and range is say 600px (for a 1200px canvas), then 600/8 = 75 frames.
                
                // Use projectileDefinitions for magicMissile
                const mmDef = projectileDefinitions.magicMissile;
                projectiles.push({
                    x:player.x+player.w/2,
                    y:player.y+player.h/2,
                    w:mmDef.drawW, // Use drawW for hitbox
                    h:mmDef.drawH, // Use drawH for hitbox
                    vx:Math.cos(angle)*8,
                    vy:Math.sin(angle)*8,
                    damage:mm.damage,
                    lifespan: Math.ceil((canvas.width / 2) / 8),
                    angle:angle,
                    type: 'magicMissile', // Type of projectile to draw correctly
                    // Initialize trail for the new missile
                    trail: [],
                    maxTrailLength: mmDef.maxTrailLength,
                    trailOpacityStart: mmDef.trailOpacityStart,
                    trailOpacityEnd: mmDef.trailOpacityEnd,
                });
            }
        }
        const aura=player.weapons.aura;if(aura.level>0){aura.rotation+=0.04;if(now-aura.lastTick>aura.cooldown){aura.lastTick=now;const orbW=16,orbH=16;for(let i=0;i<aura.orbCount;i++){const angle=aura.rotation+(i*(Math.PI*2)/aura.orbCount);const orbHitbox={x:player.x+player.w/2+Math.cos(angle)*aura.radius-orbW/2,y:player.y+player.h/2+Math.sin(angle)*aura.radius-orbH/2,w:orbW,h:orbH};enemies.forEach(enemy=>{if(checkCollision(orbHitbox,getHitbox(enemy))){enemy.currentHealth-=aura.damage;if(enemy.currentHealth<=0&&!enemy.isDead){killEnemy(enemy);}}});}}}
        const aod=player.weapons.auraOfDecay;if(aod.level>0&&now-aod.lastTick>aod.cooldown){aod.lastTick=now;enemies.forEach(enemy=>{const dx=(enemy.x+enemy.w/2)-(player.x+player.w/2);const dy=(enemy.y+enemy.h/2)-(player.y+player.h/2);const dist=Math.sqrt(dx*dx+dy*dy);if(dist<aod.radius){enemy.currentHealth-=aod.damage;if(enemy.currentHealth<=0&&!enemy.isDead){killEnemy(enemy);}}});}
    }
    // Updates projectiles
    function updateProjectiles(){
        for(let pI=projectiles.length-1;pI>=0;pI--){
            const p=projectiles[pI];

            // Add current position to trail before updating main projectile position
            if (p.type === 'magicMissile') {
                p.trail.unshift({ x: p.x, y: p.y, angle: p.angle }); // Add to front
                if (p.trail.length > p.maxTrailLength) {
                    p.trail.pop(); // Remove from back
                }
            }

            p.x+=p.vx;
            p.y+=p.vy;
            p.lifespan--;

            if(p.lifespan<=0){
                projectiles.splice(pI,1);
                continue;
            }
            for(let i=enemies.length-1;i>=0;i--){
                const e=enemies[i];
                if(checkCollision(p,getHitbox(e))){
                    e.currentHealth-=p.damage;
                    if(e.currentHealth<=0&&!e.isDead){
                        killEnemy(e);
                    }
                    projectiles.splice(pI,1);
                    break;
                }
            }
        }
    }

    // Draws debug gallery for sprites
    function drawDebugGallery() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#444'; // Neutral background for gallery
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "12px 'Press Start 2P'";
        ctx.fillStyle = '#fff';

        let x = 50;
        let y = 50;
        const spacing = 200;

        // Draws player (with visualOffsetX/Y)
        ctx.fillText("Player", x, y - 10);
        if (assets.player && assets.player.complete) {
            const sprite = assets.player;
            const frameWidth = sprite.naturalWidth / player.frameCount;
            const frameHeight = sprite.naturalHeight;
            // Apply visualOffsetX and visualOffsetY here
            ctx.drawImage(sprite, 0, 0, frameWidth, frameHeight, x + player.visualOffsetX, y + player.visualOffsetY, player.spriteW, player.spriteH);
            if (debugMode) { // Draw hitbox if debugMode is true
                ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                ctx.lineWidth = 2;
                // Hitbox remains at its logical position (x, y) + existing offsets
                ctx.strokeRect(x + player.hitboxOffsetX, y + player.hitboxOffsetY, player.w, player.h);
            }
        }
        x += spacing;

        // Draws each enemy (with visualOffsetX/Y)
        for(const key in enemyDefinitions) {
            const def = enemyDefinitions[key];
            ctx.fillText(key, x, y - 10);
            if (assets[key] && assets[key].complete) {
                const sprite = assets[key];
                const frameWidth = sprite.naturalWidth / def.frameCount;
                const frameHeight = sprite.naturalHeight;
                // Apply visualOffsetX and visualOffsetY here
                ctx.drawImage(sprite, 0, 0, frameWidth, frameHeight, x + def.visualOffsetX, y + def.visualOffsetY, def.spriteW, def.spriteH);
                if (debugMode) { // Draw hitbox if debugMode is true
                    ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                    ctx.lineWidth = 2;
                    // Hitbox remains at its logical position (x, y) + existing offsets
                    ctx.strokeRect(x + def.hitboxOffsetX, y + def.hitboxOffsetY, def.w, def.h);
                }
            }
            x += spacing;
            if (x + spacing > canvas.width) {
                x = 50;
                y += spacing;
            }
        }
        // Draw Projectile (Magic Missile) in debug gallery
        ctx.fillText("Magic Missile", x, y - 10);
        const mmDef = projectileDefinitions.magicMissile;

        // Create a dummy projectile for trail visualization
        const sampleProjectile = { 
            x: x + mmDef.drawW / 2, y: y + mmDef.drawH / 2,
            w: mmDef.drawW, h: mmDef.drawH,
            angle: 0, // Assume 0 angle for gallery
            type: 'magicMissile',
            trail: [],
            maxTrailLength: mmDef.maxTrailLength,
            trailOpacityStart: mmDef.trailOpacityStart,
            trailOpacityEnd: mmDef.trailOpacityEnd,
        };
        // Populate dummy trail for visual effect
        for(let i = 0; i < sampleProjectile.maxTrailLength; i++) {
            // Shift left for trail effect, making it appear behind
            sampleProjectile.trail.push({
                x: x + mmDef.drawW / 2 - i * (mmDef.drawW / sampleProjectile.maxTrailLength),
                y: y + mmDef.drawH / 2,
                angle: 0
            });
        }


        // Draw trail (newest to oldest, decreasing opacity)
        sampleProjectile.trail.forEach((trailPoint, index) => {
            ctx.save();
            // Calculate opacity based on position in trail
            const alpha = sampleProjectile.trailOpacityStart - (index / (sampleProjectile.maxTrailLength - 1)) * (sampleProjectile.trailOpacityStart - sampleProjectile.trailOpacityEnd);
            ctx.globalAlpha = Math.max(0, alpha); // Ensure alpha doesn't go below 0

            ctx.translate(trailPoint.x, trailPoint.y + 50); // Offset down for clear view
            ctx.rotate(trailPoint.angle);

            ctx.fillStyle = '#00FFFF'; // Same color as the main missile
            ctx.beginPath();
            ctx.moveTo(mmDef.drawW / 2, 0); 
            ctx.lineTo(-mmDef.drawW / 2, -mmDef.drawH / 2);
            ctx.lineTo(-mmDef.drawW / 2, mmDef.drawH / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        });
        ctx.globalAlpha = 1.0; // Reset globalAlpha after drawing trail

        ctx.save();
        ctx.translate(x + mmDef.drawW / 2, y + mmDef.drawH / 2); // Translate to center of drawing area for rotation
        ctx.fillStyle = '#00FFFF'; // Magic Missile color (cyan for debugging)
        ctx.beginPath();
        // Triangle pointing right
        ctx.moveTo(mmDef.drawW / 2, 0); // Tip of the triangle
        ctx.lineTo(-mmDef.drawW / 2, -mmDef.drawH / 2); // Bottom-left
        ctx.lineTo(-mmDef.drawW / 2, mmDef.drawH / 2); // Bottom-right
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        ctx.fillText(`Rendered (w,h): ${mmDef.drawW}x${mmDef.drawH}`, x, y + mmDef.drawH + 15);

        if (debugMode) {
            ctx.strokeStyle = 'rgba(255,0,0,0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, mmDef.drawW, mmDef.drawH);
        }
        x += spacing;
        if (x + spacing > canvas.width) {
            x = 50;
            y += spacing;
        }
    }

    // Main drawing function
    function draw(){
        // Only draw debug gallery if debugGalleryMode is true
        if (debugGalleryMode) {
            drawDebugGallery();
            return; // Stops normal game drawing
        }
        // Update camera position based on current canvas size
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        ctx.translate(-camera.x,-camera.y);

        // Draws repeating background
        if(backgroundPattern) {
            ctx.fillStyle = backgroundPattern;
            ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height);
        }

        // Draws obstacles with texture
        obstacles.forEach(o => { 
            if(assets.obstacle && assets.obstacle.complete) {
                // Draw the obstacle image, scaling it to fit the obstacle's dimensions
                ctx.drawImage(assets.obstacle, o.x, o.y, o.w, o.h);
            } else {
                ctx.fillStyle = '#1a1a1a'; // Fallback color if image not loaded
                ctx.fillRect(o.x, o.y, o.w, o.h);
            }
            if(debugMode) { // Draw hitbox in debug mode
                ctx.strokeStyle = 'rgba(0,0,255,0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(o.x, o.y, o.w, o.h);
            }
        });
        
        // Draws XP gems (with visualOffsetX/Y)
        xpGems.forEach(gem => { 
            if(assets.xpGem && assets.xpGem.complete && assets.xpGem.naturalHeight !== 0) {
                const sprite = assets.xpGem;
                const frameWidth = sprite.naturalWidth / gem.frameCount;
                const frameHeight = sprite.naturalHeight;
                const sourceX = gem.anim.frame * frameWidth;
                // Apply visualOffsetX and visualOffsetY here
                ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, gem.x - 16 + gem.visualOffsetX, gem.y - 16 + gem.visualOffsetY, 32, 32); 
            }
        });

        // Draws Gold coins (with visualOffsetX/Y)
        goldCoins.forEach(coin => {
            if(assets.gold && assets.gold.complete && assets.gold.naturalHeight !== 0) {
                const sprite = assets.gold;
                const frameWidth = sprite.naturalWidth / coin.frameCount;
                const frameHeight = sprite.naturalHeight;
                const sourceX = coin.anim.frame * frameWidth;
                ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, coin.x - 16 + coin.visualOffsetX, coin.y - 16 + coin.visualOffsetY, 32, 32);
            }
        });
        
        // Draws enemies and their health bars (with visualOffsetX/Y)
        enemies.forEach(e => {
            if(assets[e.type]) {
                const sprite = assets[e.type];
                if (sprite.complete && sprite.naturalHeight !== 0) {
                    const frameWidth = sprite.naturalWidth / e.frameCount;
                    const frameHeight = sprite.naturalHeight;
                    const sourceX = e.anim.frame * frameWidth;
                    // Apply visualOffsetX and visualOffsetY here
                    ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, e.x + e.visualOffsetX, e.y + e.visualOffsetY, e.spriteW, e.spriteH);
                    if(debugMode) { // Draws hitbox in debug mode
                        ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                        ctx.lineWidth = 2;
                        const hitbox = getHitbox(e);
                        ctx.strokeRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);
                    }
                }
            }
            // Draws enemy health bar (its position is linked to hitbox, not visual offset)
            if(e.currentHealth < e.health){ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fillRect(e.x+e.hitboxOffsetX,e.y+e.hitboxOffsetY-8,e.w,4);ctx.fillStyle='#c0392b';ctx.fillRect(e.x+e.hitboxOffsetX,e.y+e.hitboxOffsetY-8,e.w*(e.currentHealth/e.health),4);}
        });
    
        // Draws player with horizontal flip if necessary (with visualOffsetX/Y)
        ctx.save();
        // Calculates base sprite position (before visual offset)
        const currentSpriteX = player.x - (player.spriteW - player.w) / 2 + player.hitboxOffsetX;
        const currentSpriteY = player.y - (player.spriteH - player.h) / 2 + player.hitboxOffsetY;

        // Applies translation for rotation/flip, including visual offset
        ctx.translate(currentSpriteX + player.visualOffsetX + player.spriteW / 2, currentSpriteY + player.visualOffsetY + player.spriteH / 2);
        if (!player.anim.facingRight) { ctx.scale(-1, 1); }
        if(assets.player && assets.player.complete && assets.player.naturalHeight !== 0) {
            const sprite = assets.player;
            const frameWidth = sprite.naturalWidth / player.frameCount;
            const frameHeight = sprite.naturalHeight;
            const sourceX = player.anim.frame * frameWidth;
            // If player is invincible, make them blink
            if (player.invincible && Date.now() % 200 < 100) { // Blinks every 100ms
                ctx.globalAlpha = 0.5; // Makes player semi-transparent
            }
            ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, -player.spriteW / 2, -player.spriteH / 2, player.spriteW, player.spriteH);
            ctx.globalAlpha = 1.0; // Resets opacity
        }
        ctx.restore();
        
        // Draws player hitbox in debug mode (its position is logical, without visual offset)
        if(debugMode) {
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            ctx.lineWidth = 2;
            const hitbox = getHitbox(player);
            ctx.strokeRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);
        }

        // Draws decay aura
        const aod=player.weapons.auraOfDecay;
        if(aod.level>0){
            ctx.beginPath();
            const pulse=aod.radius+(Math.sin(Date.now()/200)*5);
            const centerX = player.x + player.w / 2;
            const centerY = player.y + player.h / 2;

            // Crée un dégradé radial (mauve au centre, noir transparent à l'extérieur)
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, // Cercle intérieur (centre, rayon 0)
                                                      centerX, centerY, pulse); // Cercle extérieur (centre, rayon = pulsation)

            // Ajoute des arrêts de couleur
            gradient.addColorStop(0, 'rgba(80, 0, 80, 0.6)'); // Mauve plus foncé au centre
            gradient.addColorStop(1,'rgba(0, 0, 0, 0.0)');  // Noir transparent au bord

            ctx.fillStyle = gradient;
            ctx.arc(centerX, centerY, pulse, 0, Math.PI * 2);
            ctx.fill();
        }
        // Draws projectiles
        projectiles.forEach(p=>{
            // Draw a triangle for Magic Missile
            if (p.type === 'magicMissile') {
                // Draw trail (newest to oldest, decreasing opacity)
                p.trail.forEach((trailPoint, index) => {
                    ctx.save();
                    // Calculate opacity based on position in trail
                    const alpha = p.trailOpacityStart - (index / (p.maxTrailLength - 1)) * (p.trailOpacityStart - p.trailOpacityEnd);
                    ctx.globalAlpha = Math.max(0, alpha); // Ensure alpha doesn't go below 0

                    ctx.translate(trailPoint.x, trailPoint.y);
                    ctx.rotate(trailPoint.angle);

                    ctx.fillStyle = '#00FFFF'; // Same color as the main missile
                    ctx.beginPath();
                    ctx.moveTo(p.w / 2, 0); 
                    ctx.lineTo(-p.w / 2, -p.h / 2);
                    ctx.lineTo(-p.w / 2, p.h / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                });
                ctx.globalAlpha = 1.0; // Reset globalAlpha after drawing trail

                ctx.save();
                ctx.translate(p.x, p.y); // Move to the center of the projectile
                ctx.rotate(p.angle);    // Rotate by its angle

                ctx.fillStyle = '#00FFFF'; // Magic Missile color (CYAN)
                ctx.beginPath();
                ctx.moveTo(p.w / 2, 0); // Tip of the triangle (pointing right)
                ctx.lineTo(-p.w / 2, -p.h / 2); // Bottom-left
                ctx.lineTo(-p.w / 2, p.h / 2); // Bottom-right
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            } else {
                // Fallback for other projectile types if any (currently none)
                ctx.fillStyle='#9b59b6';
                ctx.beginPath();
                ctx.arc(p.x,p.y,p.w/2,0,Math.PI*2);
                ctx.fill();
            }

            if(debugMode) { // Draw hitbox in debug mode (unrotated)
                ctx.strokeStyle = 'rgba(255,255,0,0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(p.x - p.w / 2, p.y - p.h / 2, p.w, p.h);
            }
        });

        // Draws aura orbs
        const aura=player.weapons.aura;if(aura.level>0){const orbW=24,orbH=24;for(let i=0;i<aura.orbCount;i++){const angle=aura.rotation+(i*(Math.PI*2)/aura.orbCount);const orbX=player.x+player.w/2+Math.cos(angle)*aura.radius-orbW/2;const orbY=player.y+player.h/2+Math.sin(angle)*aura.radius-orbH/2;const gradient=ctx.createRadialGradient(orbX+orbW/2,orbY+orbH/2,1,orbX+orbW/2,orbY+orbH/2,orbW/2);gradient.addColorStop(0,'#f1c40f');gradient.addColorStop(1,'rgba(230,126,34,0)');ctx.fillStyle=gradient;ctx.beginPath();ctx.arc(orbX+orbW/2,orbY+orbH/2,orbW/2,0,Math.PI*2);ctx.fill();}}
        
        ctx.restore();
    }

    let lastTime = 0;
    // Function to update player regeneration
    function updatePlayerRegeneration(deltaTime) {
        if (player.regenerationRate > 0) {
            // Ensure deltaTime is non-negative.
            const safeDeltaTime = Math.max(0, deltaTime);
            // deltaTime is in milliseconds, regenerationRate is in HP per second
            const healthToRegen = (player.regenerationRate * safeDeltaTime) / 1000;
            
            // Regeneration adds health. Math.min ensures not exceeding max health.
            player.health = Math.min(player.maxHealth, player.health + healthToRegen);
        }
    }

    // Main game loop
    function gameLoop(timestamp){
        if(!gameState.running) {
            requestAnimationFrame(gameLoop); // Continues drawing main menu or pause
            return;
        }
        const deltaTime=timestamp-lastTime;
        lastTime=timestamp;
        if(!gameState.paused && !debugGalleryMode){
            updatePlayer();
            spawnEnemies();
            updateEnemies();
            updateWeapons();
            updateProjectiles();
            updateXPGems();
            updateGoldCoins(); // Call the new gold coins update function
            updatePlayerRegeneration(deltaTime); // Calls regeneration function
            updatePlayerInvincibility(); // Updates invincibility state
            gameState.gameTime+=deltaTime;

            // Checks victory condition (30 minutes = 1800000 milliseconds)
            const thirtyMinutesInMs = 30 * 60 * 1000;
            if (gameState.gameTime >= thirtyMinutesInMs) {
                gameVictory();
                return; // Stops processing game logic after victory
            }
        }
        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }
    
    // Function to start the game
    function startGame() {
        mainMenu.style.display = 'none'; // Hides main menu
        mainMenuGoldUI.style.display = 'none'; // Explicitly hide gold in main menu
        gameState.gameStarted = true;
        gameState.running = true;
        gameState.paused = false;
        lastTime = performance.now(); // Resets time for a clean game loop start
        requestAnimationFrame(gameLoop); // Starts game loop
    }

    // Function to pause the game
    function pauseGame() {
        console.log('pauseGame() called. Setting pauseModal display to flex.');
        gameState.paused = true;
        pauseModal.style.display = 'flex';
        populatePauseStats(); // Updates stats in pause menu
    }

    // Function to resume the game
    function resumeGame() {
        console.log('resumeGame() called. Setting pauseModal display to none.');
        gameState.paused = false;
        pauseModal.style.display = 'none';
        lastTime = performance.now(); // Resets time to avoid large deltaTime after pause
    }

    // Function to quit the game and return to main menu
    function quitGame() {
        savePlayerGold(); // Save the current gold before quitting

        // Reset player stats (except gold, which is persistent)
        player.health = player.maxHealth;
        player.xp = 0;
        player.level = 1;
        player.xpToNextLevel = 8;
        player.regenerationRate = 0;
        player.invincible = false;
        player.invincibilityEndTime = 0;
        player.speed = 4; // Reset speed to initial value
        player.weapons.magicMissile = {level:1,cooldown:1200,lastShot:0,damage:12};
        player.weapons.aura = {level:0,radius:80,damage:5,cooldown:100,lastTick:0,rotation:0,orbCount:0};
        player.weapons.auraOfDecay = {level:0,radius:120,damage:2,cooldown:500,lastTick:0};

        // Clear all game entities
        enemies = [];
        projectiles = [];
        xpGems = [];
        goldCoins = [];
        enemySpawnTimer = 0;

        // Reset game state
        gameState.running = false;
        gameState.paused = true;
        gameState.gameTime = 0;
        gameState.killCount = 0;
        gameState.gameStarted = false;

        // Hide pause modal and show main menu
        pauseModal.style.display = 'none';
        mainMenu.style.display = 'flex';
        updateMainMenuGoldDisplay(); // Ensure main menu gold display is updated
    }

    // Function to populate pause menu statistics
    function populatePauseStats() {
        pauseLevelUI.textContent = `Niveau: ${player.level}`;
        pauseTimerUI.textContent = `Temps écoulé: ${formatTime(gameState.gameTime)}`; // Updated to use formatTime
        pauseKillCountUI.textContent = `Kills: ${gameState.killCount}`;

        pauseUpgradesList.innerHTML = ''; // Cleans list

        // Stores selected upgrades and their current levels/values
        const currentUpgrades = {};

        // Collects weapon levels
        for (const weaponId in player.weapons) {
            if (player.weapons[weaponId].level > 0) {
                currentUpgrades[weaponId] = player.weapons[weaponId].level;
            }
        }

        // Collects other stat boosts
        if (player.maxHealth > 120) {
            currentUpgrades.maxHealth = (player.maxHealth - 120) / 20; // Number of times upgraded
        }
        if (player.speed > 4) {
            currentUpgrades.speed = (player.speed - 4) / 0.5; // Number of times upgraded
        }
        if (player.regenerationRate > 0) {
            currentUpgrades.regeneration = player.regenerationRate / 0.5; // Number of times upgraded
        }

        // Maps upgrade IDs to display names and logic
        const upgradeDisplayNames = {
            magicMissile: "Missile Magique",
            aura: "Orbes de Feu",
            auraOfDecay: "Aura Néfaste",
            maxHealth: "Coeur robuste",
            speed: "Bottes de vitesse",
            regeneration: "Régénération"
        };

        // Populates list based on collected upgrades
        for (const upgradeId in currentUpgrades) {
            const li = document.createElement('li');
            const level = currentUpgrades[upgradeId];
            const displayName = upgradeDisplayNames[upgradeId] || upgradeId;

            if (upgradeId === 'regeneration') {
                li.textContent = `${displayName}: +${player.regenerationRate.toFixed(1)} PV/sec`;
            } else if (upgradeId === 'maxHealth') {
                li.textContent = `${displayName}: +${player.maxHealth - 120} Vie Max`;
            } else if (upgradeId === 'speed') {
                li.textContent = `${displayName}: +${(player.speed - 4).toFixed(1)} Vitesse`; // Use toFixed for speed
            } else {
                li.textContent = `${displayName}: Niveau ${level}`;
            }
            pauseUpgradesList.appendChild(li);
        }
    }

    // Function to load player's gold from localStorage
    function loadPlayerGold() {
        try {
            const storedGold = localStorage.getItem('playerGold');
            if (storedGold !== null) {
                player.gold = parseInt(storedGold, 10);
                console.log("Or chargé depuis localStorage :", player.gold);
            } else {
                player.gold = 0;
                console.log("Aucune donnée d'or trouvée dans localStorage, l'or est initialisé à 0.");
            }
            updateMainMenuGoldDisplay(); // Update main menu display after loading
        } catch (error) {
            console.error("Erreur lors du chargement de l'or du joueur depuis localStorage :", error);
            player.gold = 0; // Fallback in case of localStorage issues
        }
    }

    // Function to save player's gold to localStorage
    function savePlayerGold() {
        try {
            localStorage.setItem('playerGold', player.gold.toString());
            console.log("Or sauvegardé dans localStorage :", player.gold);
        } catch (error) {
            console.error("Erreur lors de la sauvegarde de l'or du joueur dans localStorage :", error);
        }
    }

    // Function to update gold display on main menu
    function updateMainMenuGoldDisplay() {
        if (mainMenuGoldUI) {
            mainMenuGoldUI.textContent = `Or: ${player.gold}`;
        }
    }

    // Game initialization function
    function init(){
        // Initializes user interface
        document.getElementById('ui-container').innerHTML=`
            <div id="stats">
                <div id="level">Niveau: 1</div>
                <div id="timer">Temps: 0s</div>
                <div id="kill-count">Kills: 0</div>
            </div>
            <div id="xp-bar-container">
                <div id="xp-bar" style="width: 0%;"></div>
                <span id="xp-text" class="bar-text">0/8</span>
            </div>
            <div id="health-bar-container">
                <div id="health-bar" style="width: 100%;"></div>
                <span id="health-text" class="bar-text">120/120</span>
            </div>
            <div id="gold-display">
                Or: <span id="gold-count">0</span>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend',`<div id="level-up-modal" class="modal"><div class="modal-content"><h2>NIVEAU SUPÉRIEUR !</h2><p>Choisissez une amélioration :</p><div id="upgrade-options"></div></div></div><div id="game-over-modal" class="modal"><div class="modal-content"><h2>GAME OVER</h2><p id="final-score"></p><button onclick="window.location.reload()">Recommencer</button></div></div>`);
        
        // Get references to UI elements
        levelUI=document.getElementById('level');
        timerUI=document.getElementById('timer');
        killCountUI=document.getElementById('kill-count');
        healthBarUI=document.getElementById('health-bar');
        xpBarUI=document.getElementById('xp-bar');
        healthTextUI=document.getElementById('health-text'); // Get reference for health text
        xpTextUI=document.getElementById('xp-text');     // Get reference for XP text
        goldUI=document.getElementById('gold-count'); // Get reference for gold count
        levelUpModal=document.getElementById('level-up-modal');
        upgradeOptionsContainer=document.getElementById('upgrade-options');
        gameOverModal=document.getElementById('game-over-modal');
        finalScoreUI=document.getElementById('final-score');
        mainMenuGoldUI = document.getElementById('main-menu-gold'); // Get reference for main menu gold

        // References to pause menu elements
        pauseLevelUI = document.getElementById('pause-level');
        pauseTimerUI = document.getElementById('pause-timer');
        pauseKillCountUI = document.getElementById('pause-kill-count');
        pauseUpgradesList = document.getElementById('pause-upgrades-list');

        // Resizes canvas and creates obstacles
        resizeCanvas();
        // Add event listener for window resize to adjust canvas size
        window.addEventListener('resize', resizeCanvas);
        createBackgroundAndObstacles();

        // Loads assets and starts game loop once everything is loaded
        loadAssets(() => {
            backgroundPattern = ctx.createPattern(assets.background, 'repeat');
            // Call loadPlayerGold after assets are loaded and UI elements are available
            loadPlayerGold(); 
            draw(); 
        });
    }

    // Calls initialization function to start the game
    init();

    // Add event listeners for the new buttons after init()
    document.addEventListener('DOMContentLoaded', () => {
        document.getElementById('startGameButton').addEventListener('click', startGame);
        document.getElementById('upgradesMenuButton').addEventListener('click', () => {
            console.log("Le bouton 'Améliorations' a été cliqué.");
            // Future functionality for upgrades menu goes here
            // For now, it just logs to the console.
        });
    });
</script>
</body>
</html>
