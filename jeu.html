<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Survivors</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Press Start 2P',-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            border: 4px solid #5a3d2b;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000;
            width: clamp(320px, 90vw, 1400px);
            height: clamp(240px, 85vh, 900px);
        }
        canvas {
            display: block;
            background-color: #333; /* Fallback */
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            pointer-events: none;
        }
        #stats {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            color: #fff;
            text-shadow: 2px 2px 2px #000;
        }
        #health-bar-container, #xp-bar-container {
            width: 100%;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.4);
            border: 2px solid #fff;
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        #health-bar {
            height: 100%;
            /* Supprimé: transition: width 0.2s ease-in-out; */
        }
        #xp-bar {
            height: 100%;
            transition: width 0.2s ease-in-out;
        }
        #health-bar { background-color: #c0392b; }
        #xp-bar { background-color: #2980b9; }
        .modal {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        .modal h2 { font-size: 24px; color: #f1c40f; margin-bottom: 20px; }
        .modal-content {
            background-color: #2c2c2c;
            padding: 30px;
            border: 4px solid #5a3d2b;
            border-radius: 10px;
            width: 80%;
            max-width: 500px;
        }
        .upgrade-option {
            background-color: #4a4a4a;
            border: 2px solid #eee;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 5px;
        }
        .upgrade-option:hover { background-color: #f1c40f; color: #1a1a1a; }
        #game-over-modal button, #main-menu button, #pause-modal button, #victory-modal button { /* Ajout des boutons de modal */
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 15px 30px;
            background-color: #f1c40f;
            color: #1a1a1a;
            border: none;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 5px;
        }

        /* Styles du menu principal */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20; /* Assurez-vous qu'il est au-dessus de tout le reste */
        }
        #main-menu h1 {
            font-size: 48px;
            color: #f1c40f;
            margin-bottom: 40px;
            text-shadow: 4px 4px 0px #e67e22;
        }
        #main-menu p {
            font-size: 24px;
            color: #fff;
            margin-top: 20px;
            animation: pulse 1.5s infinite alternate; /* Animation de pulsation */
        }
        @keyframes pulse {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(1.05); opacity: 0.8; }
        }

        /* Styles spécifiques au menu pause */
        #pause-stats p {
            font-size: 18px;
            margin: 10px 0;
            text-align: left; /* Aligner le texte à gauche pour les statistiques */
            width: 100%; /* S'assurer que le paragraphe prend toute la largeur */
        }
        #pause-stats {
            margin-bottom: 20px;
            width: 100%;
            padding: 0 20px; /* Ajout d'un peu de padding pour les statistiques */
            box-sizing: border-box; /* Inclure le padding dans la largeur */
        }
        #pause-upgrades {
            text-align: left;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
        }
        #pause-upgrades h3 {
            font-size: 20px;
            color: #f1c40f;
            margin-bottom: 10px;
        }
        #pause-upgrades ul {
            list-style: none;
            padding: 0;
        }
        #pause-upgrades li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container"></div>
    <!-- Menu principal -->
    <div id="main-menu">
        <h1>D&D Survivors</h1>
        <p>APPUYEZ SUR N'IMPORTE QUELLE TOUCHE POUR COMMENCER</p>
    </div>
    <!-- Menu Pause -->
    <div id="pause-modal" class="modal">
        <div class="modal-content">
            <h2>PAUSE</h2>
            <div id="pause-stats">
                <p id="pause-level">Niveau: </p>
                <p id="pause-timer">Temps écoulé: </p>
                <p id="pause-kill-count">Kills: </p>
            </div>
            <div id="pause-upgrades">
                <h3>Améliorations:</h3>
                <ul id="pause-upgrades-list"></ul>
            </div>
            <button onclick="resumeGame()">Reprendre</button>
        </div>
    </div>
    <!-- Écran de Victoire -->
    <div id="victory-modal" class="modal">
        <div class="modal-content">
            <h2>VICTOIRE !</h2>
            <p>Vous avez survécu 30 minutes !</p>
            <button onclick="window.location.reload()">Recommencer</button>
        </div>
    </div>
</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const uiContainer = document.getElementById('ui-container');
    const mainMenu = document.getElementById('main-menu'); // Référence au menu principal
    const pauseModal = document.getElementById('pause-modal'); // Référence au menu pause
    const victoryModal = document.getElementById('victory-modal'); // Référence à la modal de victoire

    // --- Asset Loading ---
    const assets = {};
    // Sources des images du jeu
    const assetSources = {
        player: 'images/player_spritesheet.png',
        goblin: 'images/goblin_spritesheet.png',
        skeleton: 'images/skeleton_spritesheet.png',
        slime: 'images/slime_spritesheet.png',
        orc: 'images/orc_spritesheet.png',
        xpGem: 'images/xpGem_spritesheet.png',
        background: 'images/background.png'
    };

    // Charge toutes les images définies dans assetSources
    function loadAssets(callback) {
        let loadedCount = 0;
        const totalAssets = Object.keys(assetSources).length;
        for (const key in assetSources) {
            assets[key] = new Image();
            assets[key].src = assetSources[key];
            assets[key].onload = () => {
                loadedCount++;
                if (loadedCount === totalAssets) {
                    callback();
                }
            };
            // Gère les erreurs de chargement d'image en utilisant un carré magenta
            assets[key].onerror = () => {
              console.error(`Failed to load asset: ${key} at ${assetSources[key]}`);
              const canvas = document.createElement('canvas');
              const w = 64, h = 64;
              canvas.width = w;
              canvas.height = h;
              const assetCtx = canvas.getContext('2d');
              assetCtx.fillStyle = 'magenta';
              assetCtx.fillRect(0, 0, w, h);
              assets[key].src = canvas.toDataURL();
              loadedCount++;
              if (loadedCount === totalAssets) {
                    callback();
                }
            };
        }
    }

    // --- Game State & World Setup ---
    // Dimensions du monde du jeu
    const world = { width: 3000, height: 3000 };
    let obstacles = [], backgroundPattern;
    // Éléments de l'interface utilisateur
    let levelUI, timerUI, killCountUI, healthBarUI, xpBarUI,
        levelUpModal, upgradeOptionsContainer, gameOverModal, finalScoreUI,
        pauseLevelUI, pauseTimerUI, pauseKillCountUI, pauseUpgradesList; // Nouveaux éléments UI pour la pause
    // État du jeu
    let gameState = { running: false, paused: true, gameTime: 0, killCount: 0, gameStarted: false }; // Ajout de gameStarted
    // État des touches du clavier
    let keys = {};
    // Modes de débogage
    let debugMode = false;
    let debugGalleryMode = false;
    // Caméra du jeu
    let camera = { x: 0, y: 0 };
    // Entités du jeu
    let projectiles = [], enemies = [], xpGems = [];
    let enemySpawnTimer = 0;

    // Propriétés du joueur (ajout de visualOffsetX et visualOffsetY)
    const player = {
        x:world.width/2,y:world.height/2, w: 75, h: 135, spriteW: 128, spriteH: 160, hitboxOffsetX: 0, hitboxOffsetY: 0,
        visualOffsetX: 0, visualOffsetY: -10, // Nouveaux offsets pour le rendu visuel
        speed:4,health:120,maxHealth:120,xp:0,level:1,xpToNextLevel:8,magnetRadius:100,
        regenerationRate: 0, // Nouveau: points de vie par seconde à régénérer
        invincible: false, // Nouveau: état d'invincibilité du joueur
        invincibilityEndTime: 0, // Nouveau: temps de fin de l'invincibilité
        anim:{frame:0, timer:0, speed: 15, isMoving:false,facingRight:true},
        weapons:{magicMissile:{level:1,cooldown:1200,lastShot:0,damage:12},
        aura:{level:0,radius:80,damage:5,cooldown:100,lastTick:0,rotation:0,orbCount:0},
        auraOfDecay:{level:0,radius:120,damage:2,cooldown:500,lastTick:0}},
    };
    // Définitions des ennemis (ajout de visualOffsetX et visualOffsetY)
    const enemyDefinitions={
        goblin:{type:'goblin',w:35,h:60,spriteW:128,spriteH:160, hitboxOffsetX: 45, hitboxOffsetY: 70, visualOffsetX: 0, visualOffsetY: 0, speed:1.5,health:8,damage:4,xp:2, frameCount: 10, animSpeed: 10},
        skeleton:{type:'skeleton',w:40,h:70,spriteW:64,spriteH:80, hitboxOffsetX: 12, hitboxOffsetY: 5, visualOffsetX: 0, visualOffsetY: 0, speed:1,health:20,damage:10,xp:5, frameCount: 8, animSpeed: 20},
        slime:{type:'slime',w:40,h:30,spriteW:100,spriteH:80, hitboxOffsetX: 30, hitboxOffsetY: 30, visualOffsetX: 0, visualOffsetY: 0, speed:0.8,health:30,damage:8,xp:7, frameCount: 16, animSpeed: 25},
        orc:{type:'orc',w:50,h:110,spriteW:128,spriteH:160, hitboxOffsetX: 35, hitboxOffsetY: 22, visualOffsetX: 0, visualOffsetY: 0, speed:1.2,health:50,damage:15,xp:15, frameCount: 13, animSpeed: 18},
    };
    // Définitions des objets (ex: gemmes d'XP) (ajout de visualOffsetX et visualOffsetY)
    const itemDefinitions = {xpGem: { frameCount: 7, animSpeed: 10, visualOffsetX: 0, visualOffsetY: 0 },};
    player.frameCount = 4; // Nombre de frames pour l'animation du joueur
    // Améliorations disponibles lors du passage de niveau
    const availableUpgrades=[
        {id:'magicMissile',name:'Missile Magique',description:(l)=>l===0?'Lance un projectile magique.':`+ rapide, + dégâts.`,apply:()=>{const w=player.weapons.magicMissile;w.level++;w.cooldown=Math.max(500,1200-w.level*100);w.damage+=5;}},
        {id:'aura',name:'Orbes de Feu',description:(l)=>l===0?'Un orbe de feu vous protège.':`+1 orbe, + dégâts.`,apply:()=>{const w=player.weapons.aura;w.level++;w.orbCount=w.level;w.damage+=3;if(w.level>1)w.radius+=10;}},
        {id:'auraOfDecay',name:'Aura Néfaste',description:(l)=>l===0?'Une aura qui blesse les ennemis proches.':`+ grande zone, + de dégâts.`,apply:()=>{const w=player.weapons.auraOfDecay;w.level++;w.damage+=2;w.radius+=20;}},
        {id:'maxHealth',name:'Coeur robuste',description:()=>`+20 Vie max, soigne complètement.`,apply:()=>{player.maxHealth+=20;player.health=player.maxHealth;}},
        {id:'speed',name:'Bottes de vitesse',description:()=>`Augmente la vitesse.`,apply:()=>{player.speed+=0.5;}},
        {
            id:'regeneration',
            name:'Régénération',
            description:()=>`Régénère passivement la vie. (+0.5 PV/sec)`, // Description pour l'amélioration
            apply:()=>{player.regenerationRate+=0.5;}
        }
    ];

    // Crée le fond et les obstacles du monde
    function createBackgroundAndObstacles(){obstacles=[];obstacles.push({x:-10,y:0,w:10,h:world.height},{x:world.width,y:0,w:10,h:world.height},{x:0,y:-10,w:world.width,h:10},{x:0,y:world.height,w:world.width,h:10});const pW=120,pH=160;const pP=[{x:500,y:500},{x:2500,y:500},{x:500,y:2500},{x:2500,y:2500},{x:1500,y:1000},{x:1500,y:2000}];pP.forEach(p=>{obstacles.push({x:p.x,y:p.y,w:pW,h:pH});});}
    
    // Ajuste la taille du canvas en fonction du conteneur du jeu
    function resizeCanvas(){canvas.width=gameContainer.clientWidth;canvas.height=gameContainer.clientHeight;}
    
    // Gère les événements d'appui et de relâchement des touches
    document.addEventListener('keydown', (e) => { 
        if (!gameState.gameStarted) { // Si le jeu n'a pas commencé, n'importe quelle touche le démarre
            startGame();
            return; // Sort de la fonction pour éviter de traiter la touche pour le mouvement
        }
        keys[e.key.toLowerCase()] = true; 

        if (e.key.toLowerCase() === 'escape') { // Gère la touche Échap pour la pause
            if (gameState.running && !debugGalleryMode) { // Ne pas pauser si le jeu est déjà terminé ou en mode debug gallery
                if (gameState.paused) {
                    resumeGame();
                } else {
                    pauseGame();
                }
            }
        }
        
        if (e.key.toLowerCase() === 'h') {
            debugMode = !debugMode; // Active/désactive le mode débogage
        }
        if (e.key.toLowerCase() === 'g') {
            debugGalleryMode = !debugGalleryMode; // Active/désactive le mode galerie de débogage
            uiContainer.style.display = debugGalleryMode ? 'none' : 'block';
        }
    });
    document.addEventListener('keyup',(e)=>{keys[e.key.toLowerCase()]=false;});

    // Calcule la boîte de collision d'une entité
    function getHitbox(entity) {
        return {
            x: entity.x + (entity.hitboxOffsetX || 0),
            y: entity.y + (entity.hitboxOffsetY || 0),
            w: entity.w,
            h: entity.h
        };
    }

    // Vérifie la collision entre deux rectangles
    function checkCollision(r1,r2){return r1.x<r2.x+r2.w&&r1.x+r1.w>r2.x&&r1.y<r2.y+r2.h&&r1.y+r1.h>r2.y;}
    // Vérifie la collision d'un rectangle avec une liste d'objets
    function checkCollisionWithObjects(rect,list){for(const o of list)if(checkCollision(rect,o))return true;return false;}
    
    // Met à jour la position et l'animation du joueur
    function updatePlayer(){if(!gameState.running||gameState.paused)return;let dx=0,dy=0;if(keys['w']||keys['z'])dy-=1;if(keys['s'])dy+=1;if(keys['a']||keys['q'])dx-=1;if(keys['d'])dx+=1;player.anim.isMoving=(dx!==0||dy!==0);if(player.anim.isMoving){if(dx!==0)player.anim.facingRight=dx>0;const m=Math.sqrt(dx*dx+dy*dy);const mx=(dx/m)*player.speed;const my=(dy/m)*player.speed;const nextPos = getHitbox(player);nextPos.x += mx;if(!checkCollisionWithObjects(nextPos,obstacles))player.x+=mx;nextPos.x-=mx;nextPos.y+=my;if(!checkCollisionWithObjects(nextPos,obstacles))player.y+=my;}player.anim.timer++;if(player.anim.timer>player.anim.speed){player.anim.timer=0;if(player.anim.isMoving)player.anim.frame=(player.anim.frame+1)%player.frameCount;else player.anim.frame=0;}}
    // Fait apparaître les ennemis
    function spawnEnemies(){
        if(gameState.paused)return;
        
        // Ajustement du temps entre chaque vague d'ennemis (plus long au début)
        const initialSpawnDelay = 2000; // ms
        const minSpawnDelay = 300; // ms
        const spawnDelayReductionRate = 0.05; // ms de réduction par ms de gameTime (1ms de réduction pour 20ms de temps de jeu)
        const currentSpawnDelay = Math.max(minSpawnDelay, initialSpawnDelay - gameState.gameTime * spawnDelayReductionRate);
        
        enemySpawnTimer -= 16; // Diminue le timer de 16ms (environ le temps d'une frame)
        if(enemySpawnTimer <= 0){
            enemySpawnTimer = currentSpawnDelay; // Réinitialise le timer avec la nouvelle valeur de difficulté
            
            // Ajustement du nombre d'ennemis par vague (plus faible au début)
            const initialEnemiesPerSpawn = 1;
            const enemyIncreaseRate = 1 / 45000; // 1 ennemi supplémentaire toutes les 45 secondes
            const maxEnemiesPerSpawn = 10; // Limite le nombre maximum d'ennemis par vague
            const currentEnemiesToSpawn = Math.min(maxEnemiesPerSpawn, initialEnemiesPerSpawn + Math.floor(gameState.gameTime * enemyIncreaseRate));

            for(let i=0;i<currentEnemiesToSpawn;i++){
                let x,y,sR,ok=false;
                for(let a=0;a<10;a++){ // Tente 10 fois de trouver une position valide
                    const an=Math.random()*Math.PI*2;
                    const d=Math.max(canvas.width/2,canvas.height/2)+50; // Distance du joueur
                    x=player.x+Math.cos(an)*d;
                    y=player.y+Math.sin(an)*d;
                    
                    // Utilise la nouvelle logique pour obtenir le type d'ennemi
                    const tK=getEnemyTypeByTime();
                    const t=enemyDefinitions[tK];
                    
                    sR={x,y,w:t.w,h:t.h,hitboxOffsetX:t.hitboxOffsetX,hitboxOffsetY:t.hitboxOffsetY};
                    if(!checkCollisionWithObjects(getHitbox(sR),obstacles)&&x>0&&x<world.width&&y>0&&y<world.height){
                        ok=true;
                        break;
                    }
                }
                if(ok){
                    const tK=getEnemyTypeByTime();
                    const t=enemyDefinitions[tK];
                    // Initialise lastDamageTime pour chaque nouvel ennemi
                    enemies.push({x,y,...t,currentHealth:t.health,anim:{frame:0,timer:0,speed:t.animSpeed}, lastDamageTime: 0});
                }
            }
        }
    }
    // Détermine le type d'ennemi à faire apparaître en fonction du temps de jeu
    function getEnemyTypeByTime(){
        const gameTimeSeconds = gameState.gameTime / 1000;
        let availableEnemyTypes = ['goblin']; // Les goblins apparaissent toujours

        if (gameTimeSeconds >= 5 * 60) { // Après 5 minutes (300 secondes)
            availableEnemyTypes.push('skeleton');
        }
        if (gameTimeSeconds >= 10 * 60) { // Après 10 minutes (600 secondes)
            availableEnemyTypes.push('slime');
        }
        if (gameTimeSeconds >= 15 * 60) { // Après 15 minutes (900 secondes)
            availableEnemyTypes.push('orc');
        }

        // Sélectionne un type d'ennemi aléatoire parmi ceux disponibles
        const randomIndex = Math.floor(Math.random() * availableEnemyTypes.length);
        return availableEnemyTypes[randomIndex];
    }
    // Met à jour la position et l'animation des ennemis
    function updateEnemies(){
        const now = Date.now();
        enemies.forEach(e=>{
            const dx=player.x-e.x;
            const dy=player.y-e.y;
            const d=Math.sqrt(dx*dx+dy*dy);
            if(d>1){
                const mx=(dx/d)*e.speed;
                const my=(dy/d)*e.speed;
                const nextPos=getHitbox(e);
                nextPos.x+=mx;
                if(!checkCollisionWithObjects(nextPos,obstacles))e.x+=mx;
                nextPos.x-=mx;
                nextPos.y+=my;
                if(!checkCollisionWithObjects(nextPos,obstacles))e.y+=my;
            }
            // Vérifie la collision et le temps de rechargement des dégâts de l'ennemi
            if(checkCollision(getHitbox(player),getHitbox(e))){
                const damageCooldown = 1000; // 1 seconde de délai entre chaque dégât infligé par un ennemi
                if (now - e.lastDamageTime > damageCooldown) {
                    takeDamage(e.damage); // Appel de takeDamage sans l'argument 'enemy'
                    e.lastDamageTime = now; // Met à jour le dernier temps d'infliction de dégâts pour cet ennemi
                }
            }
            e.anim.timer++;
            if(e.anim.timer>e.anim.speed){
                e.anim.timer=0;
                e.anim.frame=(e.anim.frame+1)%e.frameCount;
            }
        });
    }
    // Gère la mort d'un ennemi
    function killEnemy(enemy){
    enemy.isDead=true;
    gameState.killCount++;
    if(Math.random()<0.8){ // 80% de chance de faire apparaître une gemme d'XP
        const gemInfo = itemDefinitions.xpGem;
        xpGems.push({
            x:enemy.x+enemy.w/2,
            y:enemy.y+enemy.h/2,
            value:enemy.xp,
            anim: { frame: 0, timer: 0, speed: gemInfo.animSpeed },
            frameCount: gemInfo.frameCount,
            visualOffsetX: gemInfo.visualOffsetX, // Copie l'offset visuel
            visualOffsetY: gemInfo.visualOffsetY  // Copie l'offset visuel
        });
    }
    enemies=enemies.filter(en=>en!==enemy);
}
    // Met à jour les gemmes d'XP (animation, magnétisme, collection)
    function updateXPGems() {for (let i=xpGems.length-1;i>=0;i--){const g=xpGems[i];g.anim.timer++;if(g.anim.timer>g.anim.speed){g.anim.timer=0;g.anim.frame=(g.anim.frame+1)%g.frameCount;}const dx=(player.x+player.w/2)-g.x;const dy=(player.y+player.h/2)-g.y;const d=Math.sqrt(dx*dx+dy*dy);if(d<player.magnetRadius){g.x+=(dx/d)*6;g.y+=(dy/d)*6;}if(d<player.w/2){collectXP(g.value);xpGems.splice(i,1);}}}
    // Collecte l'XP et vérifie si le joueur monte de niveau
    function collectXP(amount){player.xp+=amount;if(player.xp>=player.xpToNextLevel){levelUp();}}
    // Gère le passage de niveau du joueur
    function levelUp(){gameState.paused=true;player.level++;player.xp-=player.xpToNextLevel;player.xpToNextLevel=Math.floor(player.xpToNextLevel*1.5);player.health=player.maxHealth;levelUpModal.style.display='flex';populateUpgradeOptions();}
    // Remplit les options d'amélioration
    function populateUpgradeOptions(){upgradeOptionsContainer.innerHTML='';const c=[],a=[...availableUpgrades];while(c.length<3&&a.length>0){const r=Math.floor(Math.random()*a.length);const o=a[r];const wL=(o.id==='magicMissile'||o.id==='aura'||o.id==='auraOfDecay')?player.weapons[o.id]?.level||0:-1;const d=document.createElement('div');d.className='upgrade-option';d.innerHTML=`<strong>${o.name}</strong><br><small>${o.description(wL)}</small>`;d.onclick=()=>selectUpgrade(o);upgradeOptionsContainer.appendChild(d);c.push(o);a.splice(r,1);}}
    // Sélectionne une amélioration
    function selectUpgrade(upgrade){upgrade.apply();levelUpModal.style.display='none';gameState.paused=false;}
    
    // Gère les dégâts subis par le joueur
    function takeDamage(amount){ 
        const now = Date.now();
        // Si le joueur est actuellement invincible, ne prend pas de dégâts
        if (player.invincible && now < player.invincibilityEndTime) {
            return;
        }

        player.health-=amount;
        
        // Active l'invincibilité après avoir subi des dégâts
        player.invincible = true;
        player.invincibilityEndTime = now + 1000; // Invincible pour 1 seconde (1000 ms)

        if(player.health<=0){
            player.health=0;
            gameOver();
        }
    }

    // Fonction pour mettre à jour l'état d'invincibilité du joueur
    function updatePlayerInvincibility() {
        const now = Date.now();
        if (player.invincible && now >= player.invincibilityEndTime) {
            player.invincible = false; // Désactive l'invincibilité si le temps est écoulé
        }
    }

    // Gère la fin du jeu
    function gameOver(){gameState.running=false;finalScoreUI.textContent=`Survécu ${Math.floor(gameState.gameTime/1000)}s, ${gameState.killCount} kills.`;gameOverModal.style.display='flex';}
    
    // Fonction de victoire
    function gameVictory() {
        gameState.running = false;
        victoryModal.style.display = 'flex';
        // Vous pouvez ajouter ici des informations spécifiques à la victoire, comme le temps final
    }

    // Trouve l'ennemi le plus proche du joueur
    function findNearestEnemy(){let n=null,nD=Infinity;enemies.forEach(e=>{const d=Math.hypot(player.x-e.x,player.y-e.y);if(d<nD){nD=d;n=e;}});return n;}
    // Met à jour l'interface utilisateur (UI)
    function updateUI(){
        levelUI.textContent=`Niveau: ${player.level}`;
        timerUI.textContent=`Temps: ${Math.floor(gameState.gameTime/1000)}s`;
        killCountUI.textContent=`Kills: ${gameState.killCount}`;
        healthBarUI.style.width=`${(player.health/player.maxHealth)*100}%`;
        xpBarUI.style.width=`${(player.xp/player.xpToNextLevel)*100}%`;
    }
    // Met à jour les armes du joueur
    function updateWeapons(){const now=Date.now();const mm=player.weapons.magicMissile;if(mm.level>0&&now-mm.lastShot>mm.cooldown){const target=findNearestEnemy();if(target){mm.lastShot=now;const dx=target.x-player.x;const dy=target.y-player.y;const angle=Math.atan2(dy,dx);projectiles.push({x:player.x+player.w/2,y:player.y+player.h/2,w:10,h:10,vx:Math.cos(angle)*8,vy:Math.sin(angle)*8,damage:mm.damage,lifespan:100,angle:angle});}}
    const aura=player.weapons.aura;if(aura.level>0){aura.rotation+=0.04;if(now-aura.lastTick>aura.cooldown){aura.lastTick=now;const orbW=16,orbH=16;for(let i=0;i<aura.orbCount;i++){const angle=aura.rotation+(i*(Math.PI*2)/aura.orbCount);const orbHitbox={x:player.x+player.w/2+Math.cos(angle)*aura.radius-orbW/2,y:player.y+player.h/2+Math.sin(angle)*aura.radius-orbH/2,w:orbW,h:orbH};enemies.forEach(enemy=>{if(checkCollision(orbHitbox,getHitbox(enemy))){enemy.currentHealth-=aura.damage;if(enemy.currentHealth<=0&&!enemy.isDead){killEnemy(enemy);}}});}}}
    const aod=player.weapons.auraOfDecay;if(aod.level>0&&now-aod.lastTick>aod.cooldown){aod.lastTick=now;enemies.forEach(enemy=>{const dx=(enemy.x+enemy.w/2)-(player.x+player.w/2);const dy=(enemy.y+enemy.h/2)-(player.y+player.h/2);const dist=Math.sqrt(dx*dx+dy*dy);if(dist<aod.radius){enemy.currentHealth-=aod.damage;if(enemy.currentHealth<=0&&!enemy.isDead){killEnemy(enemy);}}});}}
    // Met à jour les projectiles
    function updateProjectiles(){for(let pI=projectiles.length-1;pI>=0;pI--){const p=projectiles[pI];p.x+=p.vx;p.y+=p.vy;p.lifespan--;if(p.lifespan<=0){projectiles.splice(pI,1);continue;}for(let i=enemies.length-1;i>=0;i--){const e=enemies[i];if(checkCollision(p,getHitbox(e))){e.currentHealth-=p.damage;if(e.currentHealth<=0&&!e.isDead){killEnemy(e);}projectiles.splice(pI,1);break;}}}}

    // Dessine la galerie de débogage pour les sprites
    function drawDebugGallery() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#444'; // Fond neutre pour la galerie
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = "12px 'Press Start 2P'";
        ctx.fillStyle = '#fff';

        let x = 50;
        let y = 50;
        const spacing = 200;

        // Dessine le joueur (avec visualOffsetX/Y)
        ctx.fillText("Player", x, y - 10);
        if (assets.player && assets.player.complete) {
            const sprite = assets.player;
            const frameWidth = sprite.naturalWidth / player.frameCount;
            const frameHeight = sprite.naturalHeight;
            // Applique visualOffsetX et visualOffsetY ici
            ctx.drawImage(sprite, 0, 0, frameWidth, frameHeight, x + player.visualOffsetX, y + player.visualOffsetY, player.spriteW, player.spriteH);
            if (debugMode) {
                ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                ctx.lineWidth = 2;
                // Hitbox reste à sa position logique (x, y) + offsets existants
                ctx.strokeRect(x + player.hitboxOffsetX, y + player.hitboxOffsetY, player.w, player.h);
            }
        }
        x += spacing;

        // Dessine chaque ennemi (avec visualOffsetX/Y)
        for(const key in enemyDefinitions) {
            const def = enemyDefinitions[key];
            ctx.fillText(key, x, y - 10);
            if (assets[key] && assets[key].complete) {
                const sprite = assets[key];
                const frameWidth = sprite.naturalWidth / def.frameCount;
                const frameHeight = sprite.naturalHeight;
                // Applique visualOffsetX et visualOffsetY ici
                ctx.drawImage(sprite, 0, 0, frameWidth, frameHeight, x + def.visualOffsetX, y + def.visualOffsetY, def.spriteW, def.spriteH);
                if (debugMode) {
                    ctx.strokeStyle = 'rgba(255,0,0,0.8)';
                    ctx.lineWidth = 2;
                    // Hitbox reste à sa position logique (x, y) + offsets existants
                    ctx.strokeRect(x + def.hitboxOffsetX, y + def.hitboxOffsetY, def.w, def.h);
                }
            }
            x += spacing;
            if (x + spacing > canvas.width) {
                x = 50;
                y += spacing;
            }
        }
    }
    // Fonction principale de dessin
    function draw(){
         if (debugGalleryMode) {
        drawDebugGallery();
        return; // On arrête le dessin normal du jeu
    }
        camera.x=player.x-canvas.width/2;camera.y=player.y-canvas.height/2;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        ctx.translate(-camera.x,-camera.y);

        // Dessine le fond répété
        if(backgroundPattern) {
            ctx.fillStyle = backgroundPattern;
            ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height);
        }

        // Dessine les obstacles
        obstacles.forEach(o => { ctx.fillStyle = '#1a1a1a'; ctx.fillRect(o.x, o.y, o.w, o.h); });
        
        // Dessine les gemmes d'XP (avec visualOffsetX/Y)
        xpGems.forEach(gem => { 
            if(assets.xpGem && assets.xpGem.complete && assets.xpGem.naturalHeight !== 0) {
                const sprite = assets.xpGem;
                const frameWidth = sprite.naturalWidth / gem.frameCount;
                const frameHeight = sprite.naturalHeight;
                const sourceX = gem.anim.frame * frameWidth;
                // Applique visualOffsetX et visualOffsetY ici
                ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, gem.x - 16 + gem.visualOffsetX, gem.y - 16 + gem.visualOffsetY, 32, 32); 
            }
        });
        
        // Dessine les ennemis et leurs barres de vie (avec visualOffsetX/Y)
        enemies.forEach(e => {
            if(assets[e.type]) {
                const sprite = assets[e.type];
                if (sprite.complete && sprite.naturalHeight !== 0) {
                    const frameWidth = sprite.naturalWidth / e.frameCount;
                    const frameHeight = sprite.naturalHeight;
                    const sourceX = e.anim.frame * frameWidth;
                    // Applique visualOffsetX et visualOffsetY ici
                    ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, e.x + e.visualOffsetX, e.y + e.visualOffsetY, e.spriteW, e.spriteH);
                    if(debugMode) { // Dessine la hitbox en mode débogage
                        ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                        ctx.lineWidth = 2;
                        const hitbox = getHitbox(e);
                        ctx.strokeRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);
                    }
                }
            }
            // Dessine la barre de vie de l'ennemi (sa position est liée à la hitbox, pas à l'offset visuel)
            if(e.currentHealth < e.health){ctx.fillStyle='rgba(0,0,0,0.4)';ctx.fillRect(e.x+e.hitboxOffsetX,e.y+e.hitboxOffsetY-8,e.w,4);ctx.fillStyle='#c0392b';ctx.fillRect(e.x+e.hitboxOffsetX,e.y+e.hitboxOffsetY-8,e.w*(e.currentHealth/e.health),4);}
        });
    
        // Dessine le joueur avec un flip horizontal si nécessaire (avec visualOffsetX/Y)
        ctx.save();
        // Calcule la position de base du sprite (avant offset visuel)
        const currentSpriteX = player.x - (player.spriteW - player.w) / 2 + player.hitboxOffsetX;
        const currentSpriteY = player.y - (player.spriteH - player.h) / 2 + player.hitboxOffsetY;

        // Applique la translation pour la rotation/flip, en incluant l'offset visuel
        ctx.translate(currentSpriteX + player.visualOffsetX + player.spriteW / 2, currentSpriteY + player.visualOffsetY + player.spriteH / 2);
        if (!player.anim.facingRight) { ctx.scale(-1, 1); }
        if(assets.player && assets.player.complete && assets.player.naturalHeight !== 0) {
            const sprite = assets.player;
            const frameWidth = sprite.naturalWidth / player.frameCount;
            const frameHeight = sprite.naturalHeight;
            const sourceX = player.anim.frame * frameWidth;
            // Si le joueur est invincible, on le fait clignoter
            if (player.invincible && Date.now() % 200 < 100) { // Clignote toutes les 100ms
                ctx.globalAlpha = 0.5; // Rend le joueur semi-transparent
            }
            ctx.drawImage(sprite, sourceX, 0, frameWidth, frameHeight, -player.spriteW / 2, -player.spriteH / 2, player.spriteW, player.spriteH);
            ctx.globalAlpha = 1.0; // Réinitialise l'opacité
        }
        ctx.restore();
        
        // Dessine la hitbox du joueur en mode débogage (sa position est logique, sans offset visuel)
        if(debugMode) {
            ctx.strokeStyle = 'rgba(255,0,0,0.5)';
            ctx.lineWidth = 2;
            const hitbox = getHitbox(player);
            ctx.strokeRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);
        }

        // Dessine l'aura de décomposition
        const aod=player.weapons.auraOfDecay;if(aod.level>0){ctx.beginPath();ctx.fillStyle='rgba(142,68,173,0.15)';const pulse=aod.radius+(Math.sin(Date.now()/200)*5);ctx.arc(player.x+player.w/2,player.y+player.h/2,pulse,0,Math.PI*2);ctx.fill();;}
        // Dessine les projectiles
        projectiles.forEach(p=>{ctx.fillStyle='#9b59b6';ctx.beginPath();ctx.arc(p.x,p.y,p.w/2,0,Math.PI*2);ctx.fill();});
        // Dessine les orbes d'aura
        const aura=player.weapons.aura;if(aura.level>0){const orbW=24,orbH=24;for(let i=0;i<aura.orbCount;i++){const angle=aura.rotation+(i*(Math.PI*2)/aura.orbCount);const orbX=player.x+player.w/2+Math.cos(angle)*aura.radius-orbW/2;const orbY=player.y+player.h/2+Math.sin(angle)*aura.radius-orbH/2;const gradient=ctx.createRadialGradient(orbX+orbW/2,orbY+orbH/2,1,orbX+orbW/2,orbY+orbH/2,orbW/2);gradient.addColorStop(0,'#f1c40f');gradient.addColorStop(1,'rgba(230,126,34,0)');ctx.fillStyle=gradient;ctx.beginPath();ctx.arc(orbX+orbW/2,orbY+orbH/2,orbW/2,0,Math.PI*2);ctx.fill();}}
        
        ctx.restore();
    }

    let lastTime = 0;
    // Fonction pour mettre à jour la régénération du joueur
    function updatePlayerRegeneration(deltaTime) {
        if (player.regenerationRate > 0) {
            // S'assurer que deltaTime est non-négatif.
            const safeDeltaTime = Math.max(0, deltaTime);
            // deltaTime est en millisecondes, regenerationRate est en PV par seconde
            const healthToRegen = (player.regenerationRate * safeDeltaTime) / 1000;
            
            // La régénération ajoute de la vie. Math.min s'assure de ne pas dépasser la vie maximale.
            player.health = Math.min(player.maxHealth, player.health + healthToRegen);
        }
    }

    // Boucle de jeu principale
    function gameLoop(timestamp){
        if(!gameState.running) {
            requestAnimationFrame(gameLoop); // Continue de dessiner le menu principal ou pause
            return;
        }
        const deltaTime=timestamp-lastTime;
        lastTime=timestamp;
        if(!gameState.paused && !debugGalleryMode){
            updatePlayer();
            spawnEnemies();
            updateEnemies();
            updateWeapons();
            updateProjectiles();
            updateXPGems();
            updatePlayerRegeneration(deltaTime); // Appel de la fonction de régénération
            updatePlayerInvincibility(); // Met à jour l'état d'invincibilité
            gameState.gameTime+=deltaTime;

            // Vérifie la condition de victoire (30 minutes = 1800000 millisecondes)
            const thirtyMinutesInMs = 30 * 60 * 1000;
            if (gameState.gameTime >= thirtyMinutesInMs) {
                gameVictory();
                return; // Arrête le traitement de la logique de jeu après la victoire
            }
        }
        draw();
        updateUI();
        requestAnimationFrame(gameLoop);
    }
    
    // Fonction pour démarrer le jeu
    function startGame() {
        mainMenu.style.display = 'none'; // Cache le menu principal
        gameState.gameStarted = true;
        gameState.running = true;
        gameState.paused = false;
        lastTime = performance.now(); // Réinitialise le temps pour un démarrage propre de la boucle de jeu
        requestAnimationFrame(gameLoop); // Démarre la boucle de jeu
    }

    // Fonction pour mettre le jeu en pause
    function pauseGame() {
        gameState.paused = true;
        pauseModal.style.display = 'flex';
        populatePauseStats(); // Met à jour les stats dans le menu pause
    }

    // Fonction pour reprendre le jeu
    function resumeGame() {
        gameState.paused = false;
        pauseModal.style.display = 'none';
        lastTime = performance.now(); // Réinitialise le temps pour éviter un grand deltaTime après la pause
    }

    // Fonction pour remplir les statistiques du menu pause
    function populatePauseStats() {
        pauseLevelUI.textContent = `Niveau: ${player.level}`;
        pauseTimerUI.textContent = `Temps écoulé: ${Math.floor(gameState.gameTime/1000)}s`;
        pauseKillCountUI.textContent = `Kills: ${gameState.killCount}`;

        pauseUpgradesList.innerHTML = ''; // Nettoie la liste

        // Stocke les améliorations choisies et leurs niveaux/valeurs actuelles
        const currentUpgrades = {};

        // Collecte les niveaux des armes
        for (const weaponId in player.weapons) {
            if (player.weapons[weaponId].level > 0) {
                currentUpgrades[weaponId] = player.weapons[weaponId].level;
            }
        }

        // Collecte les autres augmentations de statistiques
        if (player.maxHealth > 120) {
            currentUpgrades.maxHealth = (player.maxHealth - 120) / 20; // Nombre de fois amélioré
        }
        if (player.speed > 4) {
            currentUpgrades.speed = (player.speed - 4) / 0.5; // Nombre de fois amélioré
        }
        if (player.regenerationRate > 0) {
            currentUpgrades.regeneration = player.regenerationRate / 0.5; // Nombre de fois amélioré
        }

        // Mappe les IDs des améliorations aux noms d'affichage et à la logique
        const upgradeDisplayNames = {
            magicMissile: "Missile Magique",
            aura: "Orbes de Feu",
            auraOfDecay: "Aura Néfaste",
            maxHealth: "Coeur robuste",
            speed: "Bottes de vitesse",
            regeneration: "Régénération"
        };

        // Remplit la liste en fonction des améliorations collectées
        for (const upgradeId in currentUpgrades) {
            const li = document.createElement('li');
            const level = currentUpgrades[upgradeId];
            const displayName = upgradeDisplayNames[upgradeId] || upgradeId;

            if (upgradeId === 'regeneration') {
                li.textContent = `${displayName}: +${player.regenerationRate.toFixed(1)} PV/sec`;
            } else if (upgradeId === 'maxHealth') {
                li.textContent = `${displayName}: +${player.maxHealth - 120} Vie Max`;
            } else if (upgradeId === 'speed') {
                li.textContent = `${displayName}: +${(player.speed - 4).toFixed(1)} Vitesse`; // Utilisez toFixed pour la vitesse
            } else {
                li.textContent = `${displayName}: Niveau ${level}`;
            }
            pauseUpgradesList.appendChild(li);
        }
    }


    // Fonction d'initialisation du jeu
    function init(){
        // Initialise l'interface utilisateur
        document.getElementById('ui-container').innerHTML=`<div id="stats"><div id="level">Niveau: 1</div><div id="timer">Temps: 0s</div><div id="kill-count">Kills: 0</div></div><div id="xp-bar-container"><div id="xp-bar" style="width: 0%;"></div></div><div id="health-bar-container"><div id="health-bar" style="width: 100%;"></div></div>`;
        document.body.insertAdjacentHTML('beforeend',`<div id="level-up-modal" class="modal"><div class="modal-content"><h2>NIVEAU SUPÉRIEUR !</h2><p>Choisissez une amélioration :</p><div id="upgrade-options"></div></div></div><div id="game-over-modal" class="modal"><div class="modal-content"><h2>GAME OVER</h2><p id="final-score"></p><button onclick="window.location.reload()">Recommencer</button></div></div>`);
        levelUI=document.getElementById('level');timerUI=document.getElementById('timer');killCountUI=document.getElementById('kill-count');healthBarUI=document.getElementById('health-bar');xpBarUI=document.getElementById('xp-bar');levelUpModal=document.getElementById('level-up-modal');upgradeOptionsContainer=document.getElementById('upgrade-options');gameOverModal=document.getElementById('game-over-modal');finalScoreUI=document.getElementById('final-score');
        
        // Références aux éléments du menu pause
        pauseLevelUI = document.getElementById('pause-level');
        pauseTimerUI = document.getElementById('pause-timer');
        pauseKillCountUI = document.getElementById('pause-kill-count');
        pauseUpgradesList = document.getElementById('pause-upgrades-list');

        // Redimensionne le canvas et crée les obstacles
        resizeCanvas();
        createBackgroundAndObstacles();

        // Charge les assets et démarre la boucle de jeu une fois tout chargé
        loadAssets(() => {
            backgroundPattern = ctx.createPattern(assets.background, 'repeat');
            // Nous n'appelons plus gameLoop ici directement, mais dans startGame()
            // Cependant, nous devons appeler draw() une fois pour afficher le menu principal
            draw(); 
        });
    }

    // Appelle la fonction d'initialisation pour démarrer le jeu
    init();
</script>
</body>
</html>
